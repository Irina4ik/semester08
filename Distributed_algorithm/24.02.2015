(Метод 0: Анализ диаграммы переходов)
Как описывать требования к псевдопар. прогр.?
<p1, q1, want p = 0, want q = 0, i=2>
<p1, q1, 0, 0, 2>
p1, p2, p3; p1 =def= {p=p1}
~want p || det want p = 0
i2 = {i = 2}

p1 @ p1 (эт p1, что стоит перед оператором, который указывает на p1)

***Alg. 3.8

Boolean want p <- 0,
        want q <- 0
---
p
loop forever
p1: non-crit
p2: want p <- true
p3: await
      want q = false
p4: critsec
p5: want p <- false
---
q
loop forever
q1: non-crit
q2: want q <- true
q3: await (ждём, проверка
      want p = false
q4: critsec
q5: want q <- false
---
(требование взаимно исключающего доступа)
~(@p4 ^ @q4)

@p1 - процесс p1 находится в метке p1
=> импликация

(@p1 ^ @q1) ^ (~want p ^ ~want q)
                  0         0

***Инвариант - требование, которое выполняется во всех состояниях системы.

Как доказать инвариант?
~(@p4 ^ @q4)
----
Инвариант доказывается индуктивно
1. В начальном состоянии системы показываем, что инвариант выполняется - база индукции.
2. Предположим, что инвариант выполняется в некотором сост., тогда требуется доказать, что инвариант выполняется в след. сост.

Задача построения инварианта в общем случае не разрешима (трудно выбрать инвариант)
*** Лемма 1.
    R={p3..p5 => want p}
       p3 v p4 v p5
*** Лемма 2.
    want p => p3..p5
*** Следствие 1.
    p3..p5 <=> want p
    q3..q5 <=> want q
*** Th 1.
    ~(p4 ^ q4)
----
Док-во Л1:

a b a=>b
0 0 1
0 1 1
1 0 0 !!!
1 1 1

(посылка ложна)
p1-p2 - R=1
p2 -> p3       p3..p5 = 1 |
               want p = 1 | => R = 1

p3 -> p4       want p = 1 | R = 1
p4 -> p5
p5 -> p1       p3..p5 = 0 | = R = 1
---
Док-во Л2: R={p3..p5 <=  want p}
p2 -> p3       want p = 1 |
               p3..p5 = 1 | => R = 1
p5 -> p1       want p = 0 | => R = 1
---
Док-во Th1: ~(p4 ^ q4) //1
1. База
        ~(p4 ^ q4) = ~(0 ^ 0) = 1
2. <p3, q4>     <p4, q3, ...>
        <p4, q4, ...
] <p3,q4> -> <p4,q4>
want q = 0 (p)     |
но сл.1 want q = 1 |=> противоречие
----
///Метод Флойда-Хоара
Есть структура программы, по ней производим доказательство

***LTL (linear temporal logic, линейная темпоральная логика)
f ::= p | ~f | f v f | Xf (next) | f U f (until)
терминал        нетерминал p E AP
b = S0 S1 S2 S3 ...
b, Si |= f
///Пропозициональная форма
1. b, Si |= p   iff     Si |= p
2. b, Si |= ~f  iff     непр. b, Si |= f
3. b, Si |= f1 v f2     iff     b, Si |= f1
                        или     b, Si |= f2
Лекции Ю.Г.
4. b, Si |= Xf  iff     b, S(i+1) |= f
5. b, Si |= f1 U f2     iff сущ. k >= i
        b, Sk |= f2 и
        для всех i <= j < k
        b, Sj |= f1
Семантика линейной темпоральной логики
* b |= f  iff     b,S0 |= f
вып. формула на всех выч-ях
* b1, b2, ... |= f      iff     b1,S0 |= f и
                                b2,Si |= f
вып. на некоторых вычислениях
*Ff = True U f
Future, когда-нибудь в будущем
*Gf = ~F ~f
Globally, неправда что когда-нибудь в будущем будет не f
*f1 W f2 = f1 U f2 v Gf1
weak until, сильный until или всегда выполняется это

1) Gq - всегда q (во всех состояниях)
2) Fb - когда-нибудь в будущем будет b
3) Xq - на следующем шаге q
4) a U b - оператор until, сколько хочешь <a>, до тех пор пока раз и <b>,
будущее включает настоящее
5) FG q - когда-нибудь будет q
6) GFq - когда-нибудь в будущем всегда q, бесконечно часто q, будет часто появляться

Нужно оформить требования отсутствия голодания
(для другого алгоритма)
(if какой-то процесс хочет войти в критическую зону, то он когда-нибудь в неё войдёт)
(Линейная темпоральная логика)

boolean want p <- 0,
        want q <- 0
integer turn <- 1
--
p
loop forever
p1: non-crit-sec
p2: want p <- true
p3: while want q
p4:     if (turn = 2) (не означает, что не изменится)
p5:        want p <- false
p6:        await (turn = 1)
p7:        want p <- true
p8:  crit sec
p9: turn <- 2
p10: want _ <- false
--
q
...
q6:     await(turn=2)
q8:
...
--
***LTL
*1. Сформулировать требования взаимоисключающего доступа
G ~(p8 ^ q8)
**2. Сфор-ть отсутствие голодания
G((want p = true) => F(p8))
G (p2 => Fp8)
если p2, то когда-нибудь в будущем p8

*Л1.
turn=1 v turn=2
p3..p5 v p8..p10 => want p = true
q3..q5 v q8..q10 <=> want q = true
///Пропозициональная логика
~(p8 ^ q8) ->  доказывается по индукции
**2. Дедуктивный метод
Условие прогресса
(нахождение не в критической секции является непрогрессивным)
        ~G(p1=> Fp2)
1) <- - прогрессивная опер.
любая операция присваивания прогрессивна, значит, обязательно выполняется, переход всегда выполнится
2) некр. - не прогр.
3) p4.^(turn = 2) -> Fp5 - не вып. (не можем сказать, что turn не изменится)
p4.^(turn=1) -> Fp3 - не вып.
Что вып-ся?
p4 ^ G (turn = 2) -> Fp5 - вып.
p4 ^ G (turn = 1) -> Fp3 - вып.

***Правило вывода условия прогресса
Условие вывода  G(p2=>Fp8)
--
Силлогизм-локус,
P=>Q
P
_
Q
--
метод резолюции
(~p v q) (p) (~q)
        q   
            0
Есть правила, по которым можно осуществлять вывод
GA => FB
всегда  когда-нибудь в будущем
FGA
-
FB

GF ~q1 - предпол.
обл. крит. секц. - обл. (не)прогресс.

*Док-во Л1.
want p . G(turn=1) =>
    true     ~
=> FG ~want q
q6: await (turn = 2) - застряли |
q3..5 v q8..q10 <=> want q      | => FG ~want q
**Док-во Л2. G(p2 -> Fp8) отсутствие голодания
(предположим, что это не так)
] что это не так p2 ^ ~Fp8 = p2 ^ G ~p8
                всегда неправда p8 (через G)
(прогрессивна => выполняется)
F(p2 ^ G ~p8)
когда-нибудь в будущем
(] у нас всегда turn=2)

-----
1. G(turn=2)  |
   p2 ^ G ~p8 |=> FG p6
   
   p3..p5 v p8..p10 <=> want p|
   FGp6                       |=>
   
   |FG ~want p  | => turn = 1 => пришли к противоречию
 =>|G (turn = 2)|
 F(turn=1)
 --
 2. p2 ^ G ~p8 |
    F(turn=1)  |=>инвариант
    
    |=> FG p3..4
(p2-(turn=1)->p8, p3<->p4) 
    p3..5 v p8..p10 <=> want p
                        G want p =>
                        & G (turn=1)
        =>FG ~want q => противоречие (непр.,к-н. FG  p3..p4) => G(p2=>Fp8)
(Индукт. док-во легко автомат.)

Д/з будет: SPIN 
(~C)

