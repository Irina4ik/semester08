(Метод 0: Анализ диаграммы переходов)
Как описывать требования к псевдопар. прогр.?
<p1, q1, want p = 0, want q = 0, i=2>
<p1, q1, 0, 0, 2>
p1, p2, p3; p1 =def= {p=p1}
~want p || det want p = 0
i2 = {i = 2}

p1 @ p1 (эт p1, что стоит перед оператором, который указывает на p1)

***Alg. 3.8

Boolean want p <- 0,
        want q <- 0
---
p
loop forever
p1: non-crit
p2: want p <- true
p3: await
      want q = false
p4: critsec
p5: want p <- false
---
q
loop forever
q1: non-crit
q2: want q <- true
q3: await (ждём, проверка
      want p = false
q4: critsec
q5: want q <- false
---
(требование взаимно исключающего доступа)
~(@p4 ^ @q4)

@p1 - процесс p1 находится в метке p1
=> импликация

(@p1 ^ @q1) ^ (~want p ^ ~want q)
                  0         0

***Инвариант - требование, которое выполняется во всех состояниях системы.

Как доказать инвариант?
~(@p4 ^ @q4)
----
Инвариант доказывается индуктивно
1. В начальном состоянии системы показываем, что инвариант выполняется - база индукции.
2. Предположим, что инвариант выполняется в некотором сост., тогда требуется доказать, что инвариант выполняется в след. сост.

Задача построения инварианта в общем случае не разрешима (трудно выбрать инвариант)
*** Лемма 1.
    R={p3..p5 => want p}
       p3 v p4 v p5
*** Лемма 2.
    want p => p3..p5
*** Следствие 1.
    p3..p5 <=> want p
    q3..q5 <=> want q
*** Th 1.
    ~(p4 ^ q4)
----
Док-во Л1:

a b a=>b
0 0 1
0 1 1
1 0 0 !!!
1 1 1

(посылка ложна)
p1-p2 - R=1
p2 -> p3       p3..p5 = 1 |
               want p = 1 | => R = 1

p3 -> p4       want p = 1 | R = 1
p4 -> p5
p5 -> p1       p3..p5 = 0 | = R = 1
---

