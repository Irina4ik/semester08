Шошмина Ирина Владимировна
ishoshmina@dcn.icc.spbstu.ru
9-105
BEN-ARI Principies concurrent distributed programming
1. экзамен - задача из BEN-ARI
2. зачёт/к.р.: тема-задача - презентация-доклад, посв. решению задачи
  0) Решение этой задачи,
  1) Модели на языке Promela
    SPIN,
  2) Треб.,
  3) вер. SPIN
  
--
Алгоритмы
  -посл.,
  -паралл. (одноврем.), одноврем. вып-ся, перекрытие шагов
  overlapping
Нажатие на клавишу: считывание (ввод/вывод медленней), обработка
  multitasking
  process (параллельные и распределенные алгоритмы)
  task
  multithreading
  multicomputer
  multiprocessor
  distributed system
  (память - разделяемая, распределенная)
-синхронизация процессов между собой (одноврем. потоки - останов. одновр.),
-взаимодействие между собой (ещё обмен данными).
Цель - изучить структуры, алгоритмы, подходы, связанные с распределенными алгоритмами.

Абстракции
Псевдопараллелизм (concurrency) - последовательное выполнение нескольких процессов, которые могут быть выполнены с чередованием.
Опр.:
  -послед. алгоритм - состоит из утверждений (операторов),
  -выч-е посл. алг-ма - посл. вып. утв.,
  -состояние : <указатель команд, значение всех переменных>
  <ук., на тот оператор, который будет на след. шаге>
Переход S1 в S2 - выполнение одного из утверждений, измен. знач. указ.

Алгоритм посл.
p: int n <- 0;
---
int k1 <- 1;
int k2 <- 2;
p1: n <- k1;
p2: n <- k2;
(end)
---
R={n=2} 

(Хоар)

Диаграмма сост.
  -сост. прогр.
    узел на диаг.
  -перех. прогр.
    перех. диагр. сост.

(метка)
S0 -> S1 -> S3
S0:
---
p1: n -> k1
    n=0
    k1=1
    k2=2
---
S1:
---
p2: n -> k2
    n=1
    k1=1
    k2=2
---
S2:
---
p1: (end)
    n=2
    k1=1
    k2=2
---
Опр.: Псевдопар. алг-м - мн-ва посл. алг., которые могут вып-ся с произвольным чередованием.
Сост. псевдопар. алг. - (<цель, >, <>,...<>)
S1 в S1
Переход псевдопар. алг. - вып-ие из оператора S2, на который указыв. S1
Выч-ие псевдопар. алг-ма - одна из возможных последовательностей выпонения операторов.

p|q|r|p2 
  /       |       \
  p3 -> O r2 -> O q2 -> O 
  |       |       |
  
p1  q1
p2  q2
I. Произвольное чередование
p1p2 q1q2
p1q1 p2q2

int n <- 0
---
p
---
int k1 <- 1
p1: n <- k1
(end)
---
q
---
int k2 <-2
q1: n <- k2
(end)
---

1. p1: n <- k1; q1: n <- k2; n=0; k1=1;k2=2
?2. p1: n <- k1; (end); 2; 1; 1
(end); (end); 1; 1; 2

S0->S1
|   |
V   V
S2  S3
|
V
S4
---
S0
---
p1, q1
n=0
k1=1
k2=2
---
S1
---
(end), q1
n=1
k1=1
k2=2
---
S2
---
p1,(end)
n=2
k1=1
k2=2
---
S3
---
(end),(end)
n=2
k1=1
k2=2
---
S4
---
(end), (end)
n=1
k1=1
k2=2
не зависит от скорости процессора
II. Поведение - все возможные состояния
III. Атомарность оператора
int n <- 0
---
p
---
p1: n <- n+1
---
q
---
q1: n <- k2
---
1. p1: n <- n+1; q1; n=0
2. p1; (end); 1
3. (end); (end); 2
n=2

int n <- 0
---
p
---
int t
p1: t <- n
p2: n <- t+1
---
q
---
int t
q1: t <- n
q2: n <- t+1
---1 или 2
Каждая операция атомарна
1. p1; q1; n=0; p=t; q=t
2. p1; q2; n=0; p= ; q=0
3. p2; q2; n=0; p=0; q=0
4. (end); q2; n=1; p=0; q=0
5. (end); (end); n=1; p=0; q=0
Распр. алг. не предп. завершения, в общ. случае бесконечность вычислений
-Темпоральные логики (решают задачи)
  LTL, CTL (логика ветвящего дерева, зад. бесконечного дерева событий)
  -Требование безопасности safety,
  -Требование живости liveness
  -Требование (слаб.) справедливости (weak) fairness
    если опер-р в выч. бескон. долго м.б. выпонен, то он к.-н. будет выполнен
  
int n <- 0
boolean flag <- false
---
p
---
p1: while(!flag)
p2: n <- n+1
---
q
---
q1: flag <- true
---
p1  q1
p2  q1
p1  q1
p2  q1
--
1)
M-> M->    <-F  <-F
O   O   O   O    O
  a)
  M->    
  O   O 
  
     M->    
  O   O 
  б)
  M-> M->    
  O   O   O
  
     M-> M->    
  O   O   O
<-F <-F    M->  M->
O   O   O   O    O

MM_FF (5,4,3; /2=30)
M_MFF
MFM_F
MF MF_
MF_FM
_FMFM
F_MFM
FFM_M
FF_MM

2) a, b, c - 3 упор.массива целых чисел один. размера.
Известно, что существует элемент, который принадлежит всем трем массивам.
Предложить псевдопар. алгоритм т.ч. определить наим. i,j,k, т.ч. a[i]=b[j]=c[k]

int array [0..N] a,b,c <- ... как треб.
int i <- 0, j <- 0, k <- 0
loop
p1: if (condition-1)
p2:      i <- i+1
p3: else if (condition-2)
p4:      j <- j+1
p5: else if (condition-3)
p6:       k <- k+1
else exit
loop
